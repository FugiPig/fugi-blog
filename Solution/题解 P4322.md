# 题解 P4322

题目传送门: [P4322 [JSOI2016] 最佳团体](https://www.luogu.com.cn/problem/P4322)

## 1. 题意简述

我们有一棵 $N+1$ 个节点的树, 编号分别为 $0,1,...,N$, 根节点编号为 0, 点 $i$ 的父亲是 $R_i$. 对于每个点 $i$ 有两个值 $S_i$ 和 $P_i$, 根节点的这两个值为 0. 我们要在树上找出 $K+1$ 个点, 如果要选点 $v$, 则必须选点 $v$ 的父亲 $R_v$, 根节点必须选. 设选的点集为 $X$($|X|=K+1$), 要求最大化 $\displaystyle ans=\max{\frac{\sum_{i\in X}P_i}{\sum_{i\in X}S_i}}$.

## 2. 题目解法

由于 $ans$ 的分数形式, 可以较为自然地想到使用分数规划, 对于分数规划可以参见我写的博客[0003: 分数规划简述](https://www.luogu.com.cn/blog/fugi-tech/post-0003-fen-shuo-gui-hua-jian-shu).

我们可以通过二分对 $ans$ 进行猜测, 设我们猜测的值为 $\lambda$, 则我们需要求出 $\max{\sum_{i\in X}P_i-S_i\cdot\lambda}$. 我们可以将 $\sum$ 内的值设为每个点的点权, 即对于点 $i$ 有点权 $w_i=P_i-S_i\cdot\lambda$. 

则这个问题转变为了一个树上背包的模板问题, 背包容量为 $K+1$, 每个点 $ i$ 的价值为 $w_i$, 体积为 $1$. 为了保证选每个点的时候必须选它的父亲, 我们可以在对每个点 $u$ 初始化的时候将 $dp_{u,i}$ 设为如下值:

$$dp_{u,i}=\begin{cases}w_u&(i=1)\\-\infty&(i\neq 1)\end{cases}$$ 

## 3. 时间复杂度分析

由于数据范围中 $0<S_i,P_i\le10^4$, 且 $S_i,P_i$ 均为整数, 所以二分下限为 0, 二分上限为 $\frac{10^4}{1}=10^4$. 若 $eps=10^{-6}$, 则二分次数 $k\le\log_2\frac{10^4-0}{10^{-6}}\approx 34$.

对于树上背包, 在合并 $u$ 和 $u$ 的儿子 $v$ 的时候, 若 $u$ 与已枚举的子树的并为 $sub'_u$, 则我们可以只枚举 $\min\{K+1,|sub_u'|\}\cdot\min\{K+1,|sub_v|\}$次, 相当于将已枚举的子树中的点与以 $v$ 为根的子树中的点合并. 由于任意两点只会在它们的 LCA 处合并, 所以树上背包的时间复杂度为 $\varTheta(N^2)$.

综上, 总时间复杂度为 $\varTheta(34\cdot N^2)$, 足以通过本题.

## 4. 实现

```cpp
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
const int maxn=3000;
const double eps=1e-6;
vector<int> G[maxn];
int as[maxn],ap[maxn],siz[maxn],ik,in;
double dp[maxn][maxn],mid;
void dfs(int cur)
{
	for(int v1=1;v1<=ik;v1++)dp[cur][v1]=-1e9;
	dp[cur][1]=ap[cur]-as[cur]*mid;
	siz[cur]=1;
	for(int v1=0;v1<G[cur].size();v1++)
	{
		int v=G[cur][v1];
		dfs(v);
		for(int v2=min(siz[cur],ik);v2>=1;v2--)
		{
			for(int v3=1;v3<=min(siz[v],ik-v2);v3++)dp[cur][v2+v3]=max(dp[cur][v2+v3],dp[cur][v2]+dp[v][v3]);
		}
		siz[cur]+=siz[v];
	}
}
int main()
{
	cin>>ik>>in;
	
	ik++;
	for(int v1=1;v1<=in;v1++)
	{
		int ir;
		scanf("%d %d %d",as+v1,ap+v1,&ir);
		G[ir].push_back(v1);
	}
	double l=0,r=1e9;
	while(abs(r-l)>=eps)
	{
		mid=(l+r)/2;
		dfs(0);
		if(dp[0][ik]>0)l=mid;
		else r=mid;
	}
	printf("%.3f\n",r);
	return 0;
}
```


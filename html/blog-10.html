<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Zhang San's Blog Website</title>
        <link rel="stylesheet" href="mystyle.css">
    </head>
    <body>
        <big><h1 class="title-h">张三的博客</h1></big>
        <hr width="300">
        <h2 class="title-h">Zhang San's Blog</h4>
        <h2 class="title-h">当前/Curent: 虚树简述.md</h3>
        %s
        <span class="blog-text"><h1>0014: 虚树简述</h1>
<p>本篇树上算法系列的第 1 篇, 关于本系列详见<a href="https://www.luogu.com.cn/blog/fugi-tech/post-0000-bo-ke-mu-lu">0000: 博客目录</a>.</p>
<h2>1. 例题引入</h2>
<p>例题: <a href="https://www.luogu.com.cn/problem/P2495">P2495 [SDOI2011] 消耗战</a></p>
<h3>1.1 题意简述</h3>
<p>给出一棵根为 $1$ 的 $n$ 个点的树, 边有边权: 切断 $u$ 到 $v$ 的边有 $w(u,v)$ 的代价. 有 $m$ 次询问, 每次给出 $k$ 个关键点, 保证 $1$ 不为关键点. 问通过切断一些边使得 $1$ 与任意关键点不连通的最小代价为多少?</p>
<p>$2\le n\le2.5\times10^5$, $1\le m\le 5\times10^5$, $\sum k\le5\times10^5$.</p>
<h3>1.2 在 $m=1$ 情况下的分析</h3>
<p>$m=1$, 即只有一次询问, 则这个问题就是一个简单的树形 DP 问题. 我们可以设 $dp_u$ 表示使 $u$ 与以 $u$ 为根的子树中所有的关键点不连通所需的最小代价, 若 $u$ 为关键点则 $dp_u=\infty$, 对于非关键叶子节点, 其 $dp$ 值为 $0$. 对于点 $u$, 若它的儿子所构成的集合为 $son_u$, 则可列状态转移方程如下:</p>
<p>$$\displaystyle dp_u=\sum_{v\in son_u}\min{w(u,v),dp_v}$$</p>
<p>最终答案为 $dp_1$, 单次询问时间复杂度为 $O(n)$, 总时间复杂度为 $O(nm)$, 超时.</p>
<h2>2. 虚树</h2>
<p>我们可以发现, 在上述 DP 过程中, 有很多点是没有意义的, 比如一棵没有关键点的子树. 这就引出了本篇的主题: 虚树.</p>
<p>在<strong>虚树(Virtual Tree) </strong>中, 我们只保留关键点和它们的 $lca$. 在下面的文章中, 我们设 $n$ 表示原树的点数, $k$ 表示关键点的数量, $a$ 表示关键点构成的无重复序列.</p>
<h3>2.1 虚树的构造</h3>
<p>由于我们要将任意两个关键点的 $lca$ 加入到虚树中, 如果两两进行枚举, 其时间复杂度为 $O(k^2)$, 是不可接受的. 其实, 我们可以将 $a$ 按其 $dfn$ 序从小到大排序, 得到 $a'$, 然后将 $a'$ 中任意两个相邻点的 $lca$ 加入虚树中, 即任意的 $lca(a'<em>i,a'</em>{i+1})$. 这样为什么是正确的呢? 请见如下证明:</p>
<blockquote>
<p><strong>证明</strong></p>
<p>我们使用数学归纳法, 对于任意的 $i&lt;j&lt;k$, 若 $lca(a'_i,a'_j)$ 和 $lca(a'_j,a'_k)$ 均已加入虚树中, 如果能证明 $lca(a'_i,a'_k)$ 一定在虚树中, 则得证.</p>
<p>可以发现 $lca(a'_i,a'_k)$ 应当为 $lca(a'_i,a'_j)$ 和 $lca(a'_j,a'_k)$ 中离根节点更近的点, 如果不是, 则应该为下图这种情况 ( 图中节点上的序号表示 $a$ 中这些位置的 $lca$ ):</p>
<p><img alt="" src="https://cdn.luogu.com.cn/upload/image_hosting/7sczfq70.png" /></p>
<p>可以发现, 在上图这种情况下, 应当有 $dfn_{a'<em>i}&lt;dfn</em>{a'<em>k}&lt;dfn</em>{a'<em>j}$ 或者 $dfn</em>{a'<em>j}&lt;dfn</em>{a'<em>i}&lt;dfn</em>{a'_k}$, 形成矛盾, 从而得证.</p>
</blockquote>
<p>由于我们只会把两个 $a'$ 中的相邻点加入虚树, 所以最多有 $k-1$ 个点. 而在程序编写中, 为了方便, 一般会把根节点也加入虚树, 所以虚树中最多有 $2k$ 个点.</p>
<p>还有一个细节: 对于每次询问, 我们不能将每个点的邻接表或前向星清空, 而是在将其加入虚树时清空.</p>
<h4>2.1.1 方法1: 二次排序+ $lca$ 连边</h4>
<h5>2.1.1.1 算法思路&amp;流程</h5>
<p>根据上述的讨论, 我们可以得到一个直观的方法:</p>
<ol>
<li>将 $a$ 以 $dfn$ 序从小到大排序, 得到 $a'$.</li>
<li>对于 $a'$ 中任意两个相邻点, 求它们的 $lca$.</li>
<li>将加完 $lca$ 的序列重新按 $dfn$ 序从小到大排序, 并且去重, 得到 $a''$.</li>
<li>对于 $a''$ 中相邻的两项 $a''<em>i$ 和 $a''</em>{i+1}$, 由 $lca(a''<em>i,a''</em>{i+1})$ 向 $a''_{i+1}$ 连边.</li>
</ol>
<p>为什么第 4 步这样做是正确的呢? 请见证明:</p>
<blockquote>
<p><strong>证明</strong></p>
<p>首先, 由于任意两个相邻点只会产生一条边, 所以其边数为 $|a|-1$.</p>
<p>其次, $lca(a''<em>i,a''</em>{i+1})$ 到 $a''<em>{i+1}$ 的这条路径上一定没有关键点, 否则 $dfn$ 序和 $a''_i$ 相邻的就不是 $a''</em>{i+1}$了. 所以虚树上不存在环.</p>
<p>综上, 这样建出的树是一棵合法的树.</p>
</blockquote>
<h5>2.1.1.2 时间复杂度分析</h5>
<p>时间复杂度最高的地方在求相邻点的 $lca$ 和对 $a$ 进行排序. 这样构建虚树的时间复杂度为 $O(k\log_2n)$.</p>
<h5>2.1.1.3 代码实现</h5>
<p><code>cpp
/*此注释中的内容应在主函数外
bool cmp(int a,int b)
{
    return dfn[a]&lt;dfn[b];
}
*/
sort(a1+1,a1+ik+1,cmp);//此时的 a1 表示 a', ik 表示 k
ad[1]=a1[1];
ad[2]=1;
int tot=0;
for(int v1=2;v1&lt;=ik;v1++)
{
    ad[++tot]=lca(a1[v1-1],a1[v1]);
    ad[++tot]=a1[v1];
}
sort(ad+1,ad+tot+1,cmp);
tot=unique(ad+1,ad+tot+1)-ad-1;//ad 表示 a''
for(int v1=1;v1&lt;=tot;v1++)T[ad[v1]].clear();//T 为虚树的vector邻接表存储
for(int v1=2;v1&lt;=tot;v1++)
{
    int lc=lca(ad[v1],ad[v1-1]);
    T[lc].push_back(ad[v1]);
}</code></p>
<h4>2.1.2 方法2: 以单调栈维护</h4>
<h5>2.1.2.1 算法思路&amp;流程</h5>
<ol>
<li>我们沿用方法 1 中的第 1 步, 对 $a$ 按 $dfn$ 序从小到大排序, 得到 $a'$, 但我们对 2-4 步进行简化.</li>
<li>我们遍历 $a'$, 设当前为 $a'<em>i$, 另外通过一个以 $dfn$ 为关键字的单调栈 $stack$ 维护一条从根开始的简单路径, 最开始 $stack={1}$, 设栈顶为 $stack</em>{top}$. </li>
<li>对于每个 $a'<em>i$, 求解 $lca(stack</em>{top},a'<em>i)$. 我们考虑将 $lca(stack</em>{top},a'<em>i)$ 插入单调栈中, 并使得 $lca(stack</em>{top},a'_i)$ 成为新的栈顶, 从而能让 $a'_i$ 加入这条从 $1$ 开始的路径, 这需要以下两步:</li>
<li>通过出栈将 $top$ 改为 $top'$, 使得:$dfn_{stack_{top'-1}}&lt;dfn_{lca(stack_{top},a'<em>i)}\le dfn</em>{stack_{top'}}$ 但在出栈过程中要从新栈顶向原栈顶连边, 因为我们维护的是一条从 $1$ 开始的路径.</li>
<li>如果 $lca(stack_{top},a'<em>i)\neq stack</em>{top'}$, 则从 $lca(stack_{top},a'<em>i)$ 向 $stack</em>{top'}$ 连边, 然后把 $stack_{top'}$ 设为$lca(stack_{top},a'_i)$.</li>
<li>将 $a'_i$ 入栈.</li>
<li>重复 3-4 步, 直至对 $a'$ 完成遍历.</li>
<li>将 $stack$ 中任意的相邻两项连边, 而后完成虚树构建.</li>
</ol>
<h5>2.1.2.2 时间复杂度分析</h5>
<p>与方法 1 一样, 这样构建虚树的时间复杂度也为 $O(k\log_2n)$.</p>
<h5>2.1.2.3 代码实现</h5>
<p><code>cpp
/*此注释中的内容应在主函数外
bool cmp(int a,int b)
{
    return dfn[a]&lt;dfn[b];
}
*/
sort(ah+1,ah+ik+1,cmp);//此时的 ah 表示 a'.
int top=1;
st[top]=1;//st 即为维护的单调栈
T[1].clear();
for(int v1=1;v1&lt;=ik;v1++)
{
    if(st[top]==ah[v1])continue;//排除 ah[v1]==1 的情况
    int lc=lca(st[top],ah[v1]);
    while(dfn[lc]&lt;=dfn[st[top-1]])T[st[top-1]].push_back(st[top]),top--;
    if(lc!=st[top])
    {
        T[lc].clear();
        T[lc].push_back(st[top]);
        st[top]=lc;
    }
    st[++top]=ah[v1];
    T[ah[v1]].clear();
}
for(int v1=1;v1&lt;top;v1++)T[st[v1]].push_back(st[v1+1]);</code></p>
<h3>2.2 以虚树解决例题</h3>
<p>我们只需在虚树上进行原来的 DP 即可, 但是新的 $w'(u,v)$ 要为 $u$ 到 $v$ 这条链上的 $w(u,v)$ 的最小值, 因为要断开边肯定要断开代价最小的, 这个可以和 $lca$ 一起用倍增维护.</p>
<h4>2.2.1 代码实现</h4>
<p>这是以方法 1 实现的版本:</p>
<p>```cpp</p>
<h1>include<iostream></h1>
<h1>include<vector></h1>
<h1>include<algorithm></h1>
<p>using namespace std;
const int maxn=5e5+5;
typedef long long ll;
const ll inf=0x3f3f3f3f3f3f3f3f;
vector<pair\<int,ll> > G[maxn],T[maxn];
ll dp2[maxn];
ll dfn[maxn],dep[maxn],a1[maxn],ad[maxn&lt;&lt;1],dp[maxn][25],dmin[maxn][25],vcnt;
bool vis[maxn];
void dfs(int cur,int fa)
{
    dfn[cur]=++vcnt;
    dp[cur][0]=fa;
    dep[cur]=dep[fa]+1;
    for(int v1=0;v1&lt;G[cur].size();v1++)
    {
        int v=G[cur][v1].first;
        if(v==fa)continue;
        dmin[v][0]=G[cur][v1].second;
        dfs(v,cur);
    }
}
int lca(int a,int b)
{
    if(dep[a]<dep[b])swap(a,b);
    int cha=dep[a]-dep[b];
    for(int v1=20;v1>=0;v1--)if(cha&amp;(1&lt;<v1))a=dp[a][v1];
    if(a==b)return a;
    for(int v1=20;v1>=0;v1--)if(dp[a][v1]!=dp[b][v1])
    {
        a=dp[a][v1];
        b=dp[b][v1];
    }
    return dp[a][0];
}
void dfs2(int cur,int fa)
{
    dp2[cur]=vis[cur]?inf:0;
    for(int v1=0;v1&lt;T[cur].size();v1++)
    {
        int v=T[cur][v1].first;
        if(v==fa)continue;
        dfs2(v,cur);
        dp2[cur]+=min(dp2[v],T[cur][v1].second);
    }
}
bool cmp(int a,int b)
{
    return dfn[a]&lt;dfn[b];
}
int main()
{
    int in;
    scanf("%d",&amp;in);
    for(int v1=1;v1&lt;=in-1;v1++)
    {
        int iu,iv,iw;
        scanf("%d %d %d",&amp;iu,&amp;iv,&amp;iw);
        G[iu].push_back(make_pair(iv,iw));
        G[iv].push_back(make_pair(iu,iw));
    }
    dfs(1,0);
    for(int v1=1;v1&lt;=20;v1++)for(int v2=1;v2&lt;=in;v2++)
    {
        dp[v2][v1]=dp[dp[v2][v1-1]][v1-1];
        dmin[v2][v1]=min(dmin[v2][v1-1],dmin[dp[v2][v1-1]][v1-1]);
    }
    int im;
    scanf("%d",&amp;im);
    while(im--)
    {
        int ik,tot=2;
        scanf("%d",&amp;ik);
        for(int v1=1;v1&lt;=ik;v1++)
        {
            scanf("%d",a1+v1);
            vis[a1[v1]]=true;
        }
        sort(a1+1,a1+ik+1,cmp);
        ad[1]=a1[1];
        ad[2]=1;
        for(int v1=2;v1&lt;=ik;v1++)
        {
            ad[++tot]=lca(a1[v1-1],a1[v1]);
            ad[++tot]=a1[v1];
        }
        sort(ad+1,ad+tot+1,cmp);
        tot=unique(ad+1,ad+tot+1)-ad-1;
        for(int v1=1;v1&lt;=tot;v1++)T[ad[v1]].clear();
        for(int v1=2;v1&lt;=tot;v1++)
        {
            int tmp=lca(ad[v1],ad[v1-1]),cur=ad[v1],cha=dep[cur]-dep[tmp];
            if(cur==tmp)continue;
            ll dis=inf;
            for(int v2=0;v2&lt;=20;v2++)if(cha&amp;(1&lt;&lt;v2))
            {
                dis=min(dis,(ll)dmin[cur][v2]);
                cur=dp[cur][v2];
            }
            T[tmp].push_back({ad[v1],dis});
        }
        dfs2(1,0);
        printf("%lld\n",dp2[1]);
        for(int v1=1;v1&lt;=ik;v1++)vis[a1[v1]]=false;
    }
    return 0;
}
```</p>
<h2>3. 练习题目</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P2495">P2495 [SDOI2011] 消耗战</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4103">P4103 [HEOI2014] 大工程</a></li>
<li><a href="https://www.luogu.com.cn/problem/CF613D">CF613D Kingdom and its Cities</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3233">P3233 [HNOI2014] 世界树</a></li>
<li><a href="https://www.luogu.com.cn/problem/P5439">P5439 【XR-2】永恒</a></li>
</ul>
<h2>4. 参考资料</h2>
<ol>
<li><a href="https://oi-wiki.org/graph/virtual-tree/">虚树</a> -OI wiki</li>
<li><a href="https://www.luogu.com.cn/training/9391">能力全面提升综合题单</a></li>
</ol></span>
    </body>
</html>
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>张三的博客</title>
        <link rel="stylesheet" href="mystyle.css">
    </head>
    <body>
        <big><h1 class="title-h">张三的博客</h1></big>
        <hr width="300">
        <h2 class="title-h">Zhang San's Blog</h4>
        <h2 class="title-h">当前/Current : 最大流与最小割问题简述.md</h2>
        <h2 class="title-h">分类/Category : <a style="display: inline;" href="/fugi-blog/html/node-1.html">-Blog</a><a style="display: inline;" href="/fugi-blog/html/node-3.html">-图论</a><a style="display: inline;" href="/fugi-blog/html/node-5.html">-网络流</a><br></h2>
        <div class="blog-text"><h1>0002: 最大流与最小割问题简述</h1>
<p>本篇为网络流系列的第 2 篇, 关于本系列详见<a href="https://www.luogu.com.cn/blog/fugi-tech/post-0000-bo-ke-mu-lu">0000: 博客目录</a>.</p>
<h2>1. 最大流问题</h2>
<p>最大流问题即求解网络<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>G</mi><mo>&#x0003D;</mo><mo stretchy="false">&#x00028;</mo><mi>V</mi><mo>&#x0002C;</mo><mi>E</mi><mo stretchy="false">&#x00029;</mo></mrow></math>中最大流<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi></mrow></math>的值的问题, 具体详见上一篇博客<a href="https://www.luogu.com.cn/blog/fugi-tech/wang-lao-liu-ding-yi-yu-ji-ben-xing-zhi-jian-shu">网络流定义与基本性质简述</a>.</p>
<h3>1.1 退流操作</h3>
<p>在增广过程中, 我们对于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02200;</mo><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><mi>E</mi></mrow></math>, 都建一条反向边<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mi>&#x027E9;</mi></mrow></math>, 用来维护反对称性. <strong>退流操作</strong>就是在<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow></math>增加时, 对<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo></mrow></math>应当减少同样的量, 相反同理.</p>
<blockquote>
<p><strong>Tips</strong></p>
<p>在代码实现中, 我们经常需要快速查询反向边. 在邻接矩阵中, 这是很方便的, 即<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x00028;</mo><msub><mi>g</mi><mrow><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi></mrow></msub><mo>&#x02194;</mo><msub><mi>g</mi><mrow><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi></mrow></msub><mo stretchy="false">&#x00029;</mo></mrow></math>. 但我们通常使用空间复杂度更低的链式前向星, 我们令第一条边从偶数(通常为 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>0</mn></mrow></math> ) 开始编号, 并紧挨着加入反向边, 这样可以使编号为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>i</mi></mrow></math>的边的反向边为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>i</mi><mo>&#x02295;</mo><mn>1</mn></mrow></math>.</p>
</blockquote>
<p>我们会发现反向边的流量<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo></mrow></math>可能为负, 因为实际上增广过程中重要的是<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>c</mi><mi>f</mi></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo></mrow></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo></mrow></math>的减少会带来<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>c</mi><mi>f</mi></msub><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo></mrow></math>的增加, 这意味着我们可以走反向边以抵消原来的增广, 代表一种<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x02308;</mi></mrow></math>反悔<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x0230B;</mi></mrow></math>的操作, 这样可以保证我们按正确的顺序选边.</p>
<h3>1.2 Ford-Fulkerson 增广</h3>
<p>Ford-Fulkerson 增广是一类最大流算法的总称. 该方法运用贪心思想, 通过寻找增广路来逼近直到求解最大流.</p>
<h4>1.2.1 时间复杂度的共性分析</h4>
<p>在整数流量的网络<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>G</mi><mo>&#x0003D;</mo><mo stretchy="false">&#x00028;</mo><mi>V</mi><mo>&#x0002C;</mo><mi>E</mi><mo stretchy="false">&#x00029;</mo></mrow></math>上, 我们设每次增广的流量均为整数, 则 Ford-Fulkerson 增广的时间复杂度上界为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x0007C;</mo><msup><mi>f</mi><mi>&#x02032;</mi></msup><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mi>f</mi><mi>&#x02032;</mi></msup></mrow></math>是<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>G</mi></mrow></math>上的一个最大流. 这是因为单轮增广的时间复杂度为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>, 而增广会导致<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>f</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>上升, 因此增广轮数不可能超过<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><msup><mi>f</mi><mi>&#x02032;</mi></msup><mo stretchy="false">&#x0007C;</mo></mrow></math>.</p>
<p>Ford-Fulkerson 增广的各种实现的复杂度不尽相同, 主流的实现有 Edmonds-Karp, Dinic, SAP, ISAP等, 我们将在下文中分别讲解. 在这些算法中, 求出增广轮数和单轮增广复杂度再相乘是时间复杂度分析的主要方式, 但是网络流算法的时间复杂度具有一定的~~玄学~~特殊性质, 需要具体题目具体分析.</p>
<h4>1.2.2 Edmonds-Karp 算法</h4>
<p>如何在<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>中寻找增广路呢? 最直接的方法就是 BFS, 此时 Ford-Fulkerson 增广表现为 Edmonds-Karp 算法(简称 EK 算法).</p>
<h5>1.2.2.1 算法流程</h5>
<ol>
<li>
<p>我们从源点开始 BFS. 如果在<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>上我们可以从源点 BFS 到汇点, 则说明我们找到了增广路.</p>
</li>
<li>
<p>对于一条增广路<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi></mrow></math>，我们给每一条边<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><mi>p</mi></mrow></math>都加上等量的流量<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x00394;</mi><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>p</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mo>min</mo><mrow><mo stretchy="false">&#x0007B;</mo><msub><mi>c</mi><mi>f</mi></msub><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo stretchy="false">&#x0007C;</mo><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><mi>p</mi><mo stretchy="false">&#x0007D;</mo></mrow></mrow></math>, 并给它们的反向边<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi></mrow></math>用退流操作退掉<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x00394;</mi><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>p</mi><mo stretchy="false">&#x00029;</mo></mrow></math>的流量, 这样我们就使最大流增加了<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x00394;</mi><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>p</mi><mo stretchy="false">&#x00029;</mo></mrow></math>, 而根据引理3(增广路径可增广性), 这仍是一个合法的流.</p>
</li>
<li>
<p>由于我们修改了<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>, 所以我们得到了新的<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>我们在其上重复以上过程, 直至源点和汇点不连通(即不存在增广路).</p>
</li>
</ol>
<h5>1.2.2.2 时间复杂度分析</h5>
<p>显然, 单轮 BFS 的时间复杂度为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<p>而增广轮数的上界为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>, 以下为证明:</p>
<p>对于一次增广, 我们定义<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi></mrow></math>和<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msup><mi>f</mi><mi>&#x02032;</mi></msup></mrow></math>分别为增广前后的流, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub></mrow></math>和<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>u</mi><mi>&#x02032;</mi></msubsup></mrow></math>分别为增广前后源点到点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>的最短路长度.</p>
<h6>引理2.1: 最短路非递减引理</h6>
<p>对于任意结点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>, 有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>u</mi><mi>&#x02032;</mi></msubsup><mo>&#x02265;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub></mrow></math>.</p>
<blockquote>
<p><strong>证明</strong></p>
<p>我们考虑反证法, 假设一次增广后到源点的最短路减少的点中, 到源点最短路最短的点为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi><mo>&#x0003D;</mo><mi>\arg</mi><msub><mo>min</mo><mrow><mi>v</mi><mo>&#x02208;</mo><mi>V</mi><mo>&#x0002C;</mo><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>v</mi><mi>&#x02032;</mi></msubsup><mo>&#x0003C;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub></mrow></msub><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>v</mi><mi>&#x02032;</mi></msubsup></mrow></math>. 所以根据反证假设, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>v</mi><mi>&#x02032;</mi></msubsup><mo>&#x0003C;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub></mrow></math>为已知条件.</p>
<p>我们再设源点到<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math>点最短路的上一个节点为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>, 即<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mrow><mi>u</mi></mrow><mi>&#x02032;</mi></msubsup><mo>&#x0002B;</mo><mn>1</mn><mo>&#x0003D;</mo><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>v</mi><mi>&#x02032;</mi></msubsup></mrow></math>. 为了不让<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>点代替<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math>点成为到源点最短的合法点, 必然有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mrow><mi>u</mi></mrow><mi>&#x02032;</mi></msubsup><mo>&#x02265;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mrow><mi>u</mi></mrow></msub></mrow></math>. 我们对此不等式两侧同加 1, 得<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>v</mi><mi>&#x02032;</mi></msubsup><mo>&#x02265;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mrow><mi>u</mi></mrow></msub><mo>&#x0002B;</mo><mn>1</mn></mrow></math>. 再根据反证假设进行放缩, 得<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub><mo>&#x0003E;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub><mo>&#x0002B;</mo><mn>1</mn></mrow></math>.</p>
<p>接下来我们根据此不等式进行分类讨论:</p>
<ul>
<li>若<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><msub><mi>E</mi><mi>f</mi></msub></mrow></math>, 则<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub></mrow></math>会被<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mrow><mi>u</mi></mrow></msub><mo>&#x0002B;</mo><mn>1</mn></mrow></math>更新, 所以有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mrow><mi>u</mi></mrow></msub><mo>&#x0002B;</mo><mn>1</mn><mo>&#x02265;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub></mrow></math>, 形成矛盾.</li>
<li>若<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02209;</mo><msub><mi>E</mi><mi>f</mi></msub></mrow></math>, 因为根据<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>点的定义, 我们有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><msubsup><mi>E</mi><mi>f</mi><mi>&#x02032;</mi></msubsup></mrow></math>, 所以在本轮增广中我们必然对<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mi>&#x027E9;</mi></mrow></math>进行了增广, 这样才能通过退流使<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi></mrow></math>出现. 这样, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mrow><mi>u</mi></mrow></msub><mo>&#x0003D;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub><mo>&#x0002B;</mo><mn>1</mn></mrow></math>必然成立, 形成矛盾</li>
</ul>
<p>这样, 我们完成了对引理2.1的证明.</p>
</blockquote>
<p>我们定义增广路上容量最小的边为饱和边, 有多条时任取其一. 对于饱和边<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi></mrow></math>, 我们对其进行增广后, 则这条边会消失并保证其反边的存在, 即必然有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02209;</mo><msubsup><mi>E</mi><mi>f</mi><mi>&#x02032;</mi></msubsup></mrow></math>且<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><msubsup><mi>E</mi><mi>f</mi><mi>&#x02032;</mi></msubsup></mrow></math>, 所以可以发现对于无向边<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi></mrow></math>, 其增广的方向是交替变化的.</p>
<p>由于该边在增广路上, 我们可得<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub><mo>&#x0003D;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub><mo>&#x0002B;</mo><mn>1</mn></mrow></math>, 在该轮增广完成后, 残余网络变为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>G</mi><mi>f</mi><mi>&#x02032;</mi></msubsup></mrow></math>. 我们在<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msubsup><mi>G</mi><mrow><mi>f</mi></mrow><mi>&#x02032;</mi></msubsup></mrow></math>上对<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mi>&#x027E9;</mi></mrow></math>进行增广时, 必然有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>v</mi><mi>&#x02032;</mi></msubsup><mo>&#x0002B;</mo><mn>1</mn><mo>&#x0003D;</mo><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>u</mi><mi>&#x02032;</mi></msubsup></mrow></math>, 移项得<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>v</mi><mi>&#x02032;</mi></msubsup><mo>&#x0003D;</mo><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>u</mi><mi>&#x02032;</mi></msubsup><mo>&#x02212;</mo><mn>1</mn></mrow></math>. 再根据引理2.1, 有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>v</mi><mi>&#x02032;</mi></msubsup><mo>&#x02265;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub></mrow></math>, 将上述两式代入得<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>u</mi><mi>&#x02032;</mi></msubsup><mo>&#x02265;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub><mo>&#x0002B;</mo><mn>2</mn></mrow></math>. 因此我们得到结论: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi></mrow></math>的增广方向每变化一次, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>点的最短路至少增加 2.</p>
<p>由于每个点的最短路不可能超过<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>, 所以每条边作为饱和边的次数是<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>的, 而一共有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>条边, 所以增广轮数上界为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<p>综上, Edmonds-Karp 算法的时间复杂度为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><msup><mo stretchy="false">&#x0007C;</mo><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<h5>1.2.2.3 代码实现(<a href="https://www.luogu.com.cn/problem/P3376">洛谷小数据模板P3376</a>)</h5>
<p>```cpp</p>
<h1>include<iostream></h1>
<h1>include<cstring></h1>
<h1>include<queue></h1>
<p>using namespace std;
const int maxn=205,maxm=5e3+5,inf2=0x3f3f3f3f;
typedef long long ll;
const ll inf=0x3f3f3f3f3f3f3f3f;
struct edge
{
    int to,nxt;
    ll cf;
}ae[maxm&lt;&lt;1];
int head[maxn],pree[maxn],prev_[maxn],ecnt=1,is,it,in,im;
bool vis[maxn];
void add_de(int fr,int to,int c)
{
    ae[++ecnt]={to,head[fr],c};
    head[fr]=ecnt;
    ae[++ecnt]={fr,head[to],0};
    head[to]=ecnt;
}
bool bfs()
{
    for(int v1=1;v1&lt;=in;v1++)vis[v1]=false;
    queue<int> q;
    q.push(is);
    while(!q.empty())
    {
        int cur=q.front();
        q.pop();
        vis[cur]=true;
        for(int v1=head[cur];v1!=-1;v1=ae[v1].nxt)
        {
            int v=ae[v1].to;
            if(!vis[v]&amp;&amp;ae[v1].cf)
            {
                vis[v]=true;
                pree[v]=v1;
                prev_[v]=cur;
                q.push(v);
            }
        }
    }
    return vis[it];
}
int main()
{
    memset(head,-1,sizeof(head));
    cin&gt;&gt;in&gt;&gt;im&gt;&gt;is&gt;&gt;it;
    for(int v1=1;v1&lt;=im;v1++)
    {
        int iu,iv,iw;
        scanf("%d %d %d",&amp;iu,&amp;iv,&amp;iw);
        add_de(iu,iv,iw);
    }
    ll ans=0;
    while(bfs())
    {
        ll minflow=inf;
        for(int v1=it;v1!=is;v1=prev_[v1])
            minflow=min(minflow,ae[pree[v1]].cf);
        for(int v1=it;v1!=is;v1=prev_[v1])
        {
            ae[pree[v1]].cf-=minflow;
            ae[pree[v1]^1].cf+=minflow;
        }
        ans+=minflow;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
```</p>
<h4>1.2.3 Dinic算法</h4>
<h5>1.2.3.1 算法思路</h5>
<p>我们在残余网络<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>上通过 BFS 进行分层, 即根据每个点到源点的最短路(这里将<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>点的最短路设为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub></mrow></math>). 我们使每个节点的流只能流向下一层的节点, 相当于将<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub><mo>&#x0002B;</mo><mn>1</mn><mo>&#x02260;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub></mrow></math>的边<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi></mrow></math>删除, 形成一个有向无环图(DAG), 我们将这个 DAG 称为<strong>层次图(Level Graph)</strong>. 形式化地, 我们设这个层次图为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>L</mi></msub><mo>&#x0003D;</mo><mo stretchy="false">&#x00028;</mo><mi>V</mi><mo>&#x0002C;</mo><msub><mi>E</mi><mi>L</mi></msub><mo stretchy="false">&#x00029;</mo></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>E</mi><mi>L</mi></msub><mo>&#x0003D;</mo><mo stretchy="false">&#x0007B;</mo><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo stretchy="false">&#x0007C;</mo><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><msub><mi>E</mi><mi>f</mi></msub><mo>&#x0002C;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub><mo>&#x0002B;</mo><mn>1</mn><mo>&#x0003D;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub><mo stretchy="false">&#x0007D;</mo></mrow></math>.</p>
<p>我们对<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>L</mi></msub></mrow></math>进行增广, 找到一个最大的增广流<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>f</mi><mi>b</mi></msub></mrow></math>(这里指广义上的增广, 即增广流可以是多条增广流的并), 使得<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>L</mi></msub></mrow></math>上不存在更大的增广流, 则我们称<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>f</mi><mi>b</mi></msub></mrow></math>是<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>L</mi></msub></mrow></math>的<strong>阻塞流(Blocking Flow)</strong>.</p>
<blockquote>
<p><strong>广义的增广</strong></p>
<p>上文中我们的增广和增广流都是定义在单条增广路上的, 但广义上的增广流可以是多条狭义增广流的并, 我们在定义阻塞流时指的也是广义的增广流.</p>
</blockquote>
<h5>1.2.3.2 算法流程</h5>
<ol>
<li>在残余网络<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>上通过 BFS 求出层次图<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>L</mi></msub></mrow></math>.</li>
<li>在<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>L</mi></msub></mrow></math>上通过 DFS 进行增广, 求出阻塞流<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>f</mi><mi>b</mi></msub></mrow></math>.</li>
<li>将<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>f</mi><mi>b</mi></msub></mrow></math>合并到原先的流<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi></mrow></math>中, 即<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi><mo>&#x02190;</mo><mi>f</mi><mo>&#x0002B;</mo><msub><mi>f</mi><mi>b</mi></msub></mrow></math>.</li>
<li>重复<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>1</mn><mo>&#x02192;</mo><mn>3</mn></mrow></math>步, 直至源点和汇点不连通.</li>
</ol>
<p>此时, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi></mrow></math>即为最大流.</p>
<h5>1.2.3.3 当前弧"优化"</h5>
<p>为了降低 DFS 求解阻塞流的时间复杂度, 我们需要引入<strong>当前弧优化</strong>.</p>
<p>我们发现在<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>L</mi></msub></mrow></math>上 DFS 的过程中, 如果结点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>同时具有大量入边和出边, 并且每次 DFS 到<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>时都遍历出边表来进行增广, 则<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>这个局部的时间复杂度最坏可达<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><msup><mo stretchy="false">&#x0007C;</mo><mn>2</mn></msup><mo stretchy="false">&#x00029;</mo></mrow></math>. 为避免这一缺陷, 如果某一时刻边<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi></mrow></math>已经增广到极限(<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>c</mi><mi>f</mi></msub><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mn>0</mn></mrow></math>或<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math>点的后侧已增广至阻塞), 则<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi></mrow></math>已经没有访问的意义. 因此, 我们可以维护每个点的出边表中第一条还有必要尝试的出边. 习惯上, 我们称维护的这条出边为当前弧(在求解欧拉路径等问题中有类似的应用), 称这个做法为当前弧优化.</p>
<p>由于当前弧优化实际上是保证 Dinic 算法时间复杂度的一部分, 所以并不可以称为 Dinic 算法的优化, 我们会在下文中解释这一点.</p>
<h5>1.2.3.4 多路增广</h5>
<p>多路增广是 Dinic 算法的一个常数优化, 当我们找到一条从源点到汇点的增广路<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi></mrow></math>时, 我们没有必要再次从源点开始寻找, 而是在<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi></mrow></math>上的最后一个有剩余容量的结点继续寻找, 由于其与 DFS 的回溯性质的高度一致, 其在实现中也是自然而然的.</p>
<h5>1.2.3.5 时间复杂度分析</h5>
<p>在应用当前弧优化后, 单轮增广的时间复杂度为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<blockquote>
<p><strong>证明</strong></p>
<p>由于层次图是一个 DAG, 且其层数不可能超过<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>, 所以每条增广路的跳转次数不可能超过<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>.</p>
<p>我们设<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow></math>包含本次增广后形成的饱和边(即剩余容量为0), 又因为层次图的限制, 饱和边产生的反向边不可能在本轮增广中被访问. 因此, 对于每条增广路<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi></mrow></math>, 必然对于至少一条边<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><msub><mi>E</mi><mn>1</mn></msub></mrow></math>, 有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><mi>p</mi></mrow></math>.</p>
<p>我们再令<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow></math>包含每条增广失败的增广路所途径的最后一条边, 因为我们进行了当前弧优化, 而<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow></math>中的边指向的结点均已堵塞, 所以每条<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow></math>中的边会在访问后删除. 由于这些边不可能饱和(否则无法称为增广路上的边), 所以又有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>&#x02229;</mo><msub><mi>E</mi><mn>2</mn></msub><mo>&#x0003D;</mo><mo>&#x02205;</mo></mrow></math>, 且<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>&#x0222A;</mo><msub><mi>E</mi><mn>2</mn></msub><mo>&#x02286;</mo><msub><mi>E</mi><mi>L</mi></msub></mrow></math>. </p>
<p>又因为每条<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow></math>或<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow></math>中的边均对应唯一一条增广路, 而每条增广路最多跳转<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>次, 所以单轮增广时间复杂度上上界为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
</blockquote>
<p>接下来我们引入层次图层数单调递增引理, 若该引理得证, 又因为层次图层数最大为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>, 就可以证明增广轮数上限为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>.</p>
<h6>引理2.2: 层次图层数单调递增引理</h6>
<p>对于每次增广, 汇点的层数至少增加 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>1</mn></mrow></math>, 也即<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>t</mi></msub></mrow></math>至少增加 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>1</mn></mrow></math>.</p>
<blockquote>
<p><strong>证明</strong></p>
<p>我们发现, 因为增广前源点到汇点的最短路定然在<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>L</mi></msub></mrow></math>上, 而这些最短路会因为增广而断开, 所以若<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>t</mi></msub><mo>&#x0003D;</mo><mi>d</mi><mi>i</mi><msubsup><mi>s</mi><mi>t</mi><mi>&#x02032;</mi></msubsup></mrow></math>, 则满足此条件的这条新的最短路上必然包含一条增广产生的反边(否则这条最短路必然存在于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>上, 进而存在于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>L</mi></msub></mrow></math>上). 因此, 我们只需要证明包含反边的源点到汇点的路径长度大于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>t</mi></msub></mrow></math>即可.</p>
<p>我们设一条包含反边的源点到汇点的路径<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi></mrow></math>, 再设<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mi>&#x027E9;</mi></mrow></math>是<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi></mrow></math>上的最后一条反边. 由于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>到汇点的这段路径上不包含反边, 再根据引理2.1(最短路非递减引理), 得到其长度最短为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>t</mi></msub><mo>&#x02212;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub></mrow></math>. 而最短路非递减引理也可说明源点到<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>v</mi></mrow></math>点的这段路径的最短长度为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>v</mi></msub></mrow></math>, 也就等于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub><mo>&#x0002B;</mo><mn>1</mn></mrow></math>. 再加上这条反边的长度, 我们可以得到<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>p</mi></mrow></math>的长度至少为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x00028;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>t</mi></msub><mo>&#x02212;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><mo stretchy="false">&#x00028;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub><mo>&#x0002B;</mo><mn>1</mn><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><mn>1</mn><mo>&#x0003D;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>t</mi></msub><mo>&#x0002B;</mo><mn>2</mn></mrow></math>, 从而得证.  </p>
</blockquote>
<p>综上, 我们可以得到 Dinic 算法在一般网络上的时间复杂度为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mn>2</mn></msup><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<h5>1.2.3.6 单位容量网络上的时间复杂度分析</h5>
<p>在具有单位容量性质的网络上, Dinic 算法拥有更好的时间复杂度.</p>
<p>我们称一个网络<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>G</mi><mo>&#x0003D;</mo><mo stretchy="false">&#x00028;</mo><mi>V</mi><mo>&#x0002C;</mo><mi>E</mi><mo stretchy="false">&#x00029;</mo></mrow></math>是<strong>单位容量</strong>(Unit Capacity)的, 当且仅当对于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02200;</mo><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><mi>E</mi></mrow></math>, 均有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>c</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02208;</mo><mo stretchy="false">&#x0007B;</mo><mn>0</mn><mo>&#x0002C;</mo><mn>1</mn><mo stretchy="false">&#x0007D;</mo></mrow></math>. 我们接下来说明 Dinic 算法在单位容量网络上的时间复杂度.</p>
<p>单位容量网络上每轮增广时间复杂度为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<blockquote>
<p><strong>证明</strong></p>
<p>我们每对一条增广路进行增广, 就会导致增广路上的所有边饱和而消失, 所以每条边在单轮增广只能被增广一次.</p>
</blockquote>
<p>为了证明单位容量网络上增广轮数上限, 我们在分层图上定义<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>D</mi><mi>k</mi></msub><mo>&#x0003D;</mo><mo stretchy="false">&#x0007B;</mo><mi>u</mi><mo stretchy="false">&#x0007C;</mo><mi>u</mi><mo>&#x02208;</mo><mi>V</mi><mo>&#x0002C;</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>u</mi></msub><mo>&#x0003D;</mo><mi>k</mi><mo stretchy="false">&#x0007D;</mo></mrow></math>, 即第<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>k</mi></mrow></math>层的点集. 我们还定义<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>S</mi><mi>k</mi></msub><mo>&#x0003D;</mo><msub><mo>&#x0222A;</mo><mrow><mi>i</mi><mo>&#x02264;</mo><mi>k</mi></mrow></msub><msub><mi>D</mi><mi>k</mi></msub></mrow></math>, 即前<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>k</mi></mrow></math>层的点集. 我们继续定义<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>F</mi><mi>k</mi></msub><mo>&#x0003D;</mo><mo stretchy="false">&#x0007B;</mo><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo stretchy="false">&#x0007C;</mo><mi>u</mi><mo>&#x02208;</mo><msub><mi>D</mi><mi>k</mi></msub><mo>&#x0002C;</mo><mi>v</mi><mo>&#x02208;</mo><msub><mi>D</mi><mrow><mi>k</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo>&#x0002C;</mo><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><mi>E</mi><mo stretchy="false">&#x0007D;</mo></mrow></math>, 即第<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>k</mi></mrow></math>层到第<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>k</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></math>层的边集.</p>
<p>单位容量网络上的增广轮数上限为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt><mo stretchy="false">&#x00029;</mo></mrow></math>  .</p>
<blockquote>
<p><strong>证明</strong></p>
<p>假设我们已经进行了<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></math>次增广, 根据引理2.2, 至少存在<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></math>个层次, 而一共有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>条边. 因此根据抽屉原理, 至少存在一个<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>F</mi><mi>k</mi></msub><mo>&#x02264;</mo><mfrac><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow><mrow><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></mfrac><mo>&#x02248;</mo><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></math>. 显然, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007B;</mo><msub><mi>S</mi><mi>k</mi></msub><mo>&#x0002C;</mo><mi>V</mi><mo>&#x02212;</mo><msub><mi>S</mi><mi>k</mi></msub><mo stretchy="false">&#x0007D;</mo></mrow></math>是一个<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>S</mi><mo>&#x02212;</mo><mi>T</mi></mrow></math>割, 而其容量至多为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></math>. 根据定理1.6(最大流最小割定理), 最多还能进行<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></math>次增广, 从而得证.</p>
</blockquote>
<p>单位容量网络上的增广轮数上限为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup><mo stretchy="false">&#x00029;</mo></mrow></math>. </p>
<blockquote>
<p><strong>证明</strong>
假设我们已经进行了<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mn>2</mn><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>轮增广. 由于至多有半数(<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>个)的层次包含多于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>个点, 故无论我们如何分配所有层次的大小, 至少存在一个<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>k</mi></mrow></math>满足相邻两个层次同时包含不多于  <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>个点, 即  <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><msub><mi>D</mi><mi>k</mi></msub><mo stretchy="false">&#x0007C;</mo><mo>&#x02264;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>且  <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><msub><mi>D</mi><mrow><mi>k</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&#x0007C;</mo><mo>&#x02264;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>1</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>. </p>
<p>为最大化<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>D</mi><mi>k</mi></msub></mrow></math>和<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>D</mi><mrow><mi>k</mi><mo>&#x0002B;</mo><mn>1</mn></mrow></msub></mrow></math>之间的边数, 我们假定这是一个完全二分图, 此时<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><msub><mi>F</mi><mi>k</mi></msub><mo stretchy="false">&#x0007C;</mo></mrow></math>不超过  <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>. 显然, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007B;</mo><msub><mi>S</mi><mi>k</mi></msub><mo>&#x0002C;</mo><mi>V</mi><mo>&#x02212;</mo><msub><mi>S</mi><mi>k</mi></msub><mo stretchy="false">&#x0007D;</mo></mrow></math>是<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>上的<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>s</mi><mo>&#x02212;</mo><mi>t</mi></mrow></math>割, 且其割容量不超过  <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>. 根据定理1.6(最大流最小割定理) , <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>上的最大流不超过<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>, 也即<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>上最多还能进行<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup></mrow></math>轮增广. 因此, 总增广轮数是  <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>O</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup><mo stretchy="false">&#x00029;</mo></mrow></math>的. </p>
</blockquote>
<p>综上, 在单位容量网络上 Dinic 算法的时间复杂度为 <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><mi>&#x000B7;</mi><mo>min</mo><mo stretchy="false">&#x0007B;</mo><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt><mo>&#x0002C;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><msup><mo stretchy="false">&#x0007C;</mo><mrow><mfrac><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></mfrac></mrow></msup><mo stretchy="false">&#x0007D;</mo><mo stretchy="false">&#x00029;</mo></mrow></math>.</p>
<h5>1.2.3.7 在性质更优良网络上的时间复杂度分析</h5>
<p>在单位容量的网络中, 如果对于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02200;</mo><mi>u</mi><mo>&#x02209;</mo><mi>V</mi><mo>&#x02212;</mo><mo stretchy="false">&#x0007B;</mo><mi>s</mi><mo>&#x0002C;</mo><mi>t</mi><mo stretchy="false">&#x0007D;</mo></mrow></math>, 存在点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>的出度或入度为 1, 则 Dinic 算法的增广轮数上限为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt><mo stretchy="false">&#x00029;</mo></mrow></math>. </p>
<blockquote>
<p><strong>证明</strong></p>
<p>我们引入以下引理: 对于这一形式的网络, 其上的任意流总是可以分解成若干条单位流量的, 点不交(除源汇点不交)的增广路. </p>
<p>假设我们已经进行了<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></math>轮增广. 根据层次图的定义, 此时任意新的增广路的长度至少为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></math> </p>
<p>考虑<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>上的最大流的增广路分解, 我们得到的增广路的数量不能多于    <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mfrac><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow><mrow><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></mfrac><mo>&#x02248;</mo><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></math>, 这意味着<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow></math>上最多还能执行<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt></mrow></math>轮增广. 因此,增广轮数上限为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>O</mi><mo stretchy="false">&#x00028;</mo><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt><mo stretchy="false">&#x00029;</mo></mrow></math>. </p>
</blockquote>
<p>因此, 在具有上面特殊性质的单位容量网络中, Dinic 算法的时间复杂度为<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x1D6E9;</mi><mo stretchy="false">&#x00028;</mo><mo stretchy="false">&#x0007C;</mo><mi>E</mi><mo stretchy="false">&#x0007C;</mo><msqrt><mrow><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></msqrt><mo stretchy="false">&#x00029;</mo></mrow></math>, 这种特殊性质其实是进行二分图最大匹配时的情况.</p>
<h5>1.2.3.8 代码实现(<a href="https://www.luogu.com.cn/problem/P3376">洛谷小数据模板P3376</a>)</h5>
<p>```cpp</p>
<h1>include<iostream></h1>
<h1>include<queue></h1>
<h1>include<cstring></h1>
<p>using namespace std;
const int maxn=205,maxm=5e3+5,infi=0x3f3f3f3f;
typedef long long ll;
struct edge
{
    int to,nxt;
    ll cf;
}ae[maxm&lt;&lt;1];
const ll inf=0x3f3f3f3f3f3f3f3f;
int dep[maxn],head[maxn],curhead[maxn],in,im,is,it,ecnt=1;
void add_de(int fr,int to,ll c)
{
    ae[++ecnt]={to,head[fr],c};
    head[fr]=ecnt;
    ae[++ecnt]={fr,head[to],0};
    head[to]=ecnt;
}
bool bfs()
{
    for(int v1=1;v1&lt;=in;v1++)dep[v1]=infi;
    queue<int> q;
    q.push(is);
    dep[is]=0;
    while(!q.empty())
    {
        int cur=q.front();
        q.pop();
        for(int v1=head[cur];v1!=-1;v1=ae[v1].nxt)
        {
            int v=ae[v1].to;
            if(ae[v1].cf&amp;&amp;dep[v]&gt;dep[cur]+1)
            {
                dep[v]=dep[cur]+1;
                q.push(v);
            }
        }
    }
    return dep[it]!=infi;
}
ll dinic(int cur,ll flow)
{
    if(!flow||cur==it)return flow;
    ll res=0;
    for(int &amp;v1=curhead[cur];v1!=-1;v1=ae[v1].nxt)
    {
        int v=ae[v1].to;
        if(dep[v]!=dep[cur]+1)continue;
        ll k=dinic(v,min(flow-res,ae[v1].cf));
        ae[v1].cf-=k;
        ae[v1^1].cf+=k;
        res+=k;
        if(res==flow)break;
    }
    return res;
}
int main()
{
    memset(head,-1,sizeof(head));
    cin&gt;&gt;in&gt;&gt;im&gt;&gt;is&gt;&gt;it;
    for(int v1=1;v1&lt;=im;v1++)
    {
        int iu,iv,iw;
        scanf("%d %d %d",&amp;iu,&amp;iv,&amp;iw);
        add_de(iu,iv,iw);
    }
    ll maxflow=0;
    while(bfs())
    {
        for(int v1=1;v1&lt;=in;v1++)curhead[v1]=head[v1];
        maxflow+=dinic(is,inf);
    }
    cout&lt;&lt;maxflow&lt;&lt;endl;
    return 0;
}
```</p>
<h4>1.2.4 MPM算法</h4>
<p><em>待补充</em></p>
<h4>1.2.5 ISAP 算法</h4>
<h3>1.3 推送-重贴标签算法(预流推进算法)</h3>
<p>推送-重贴标签算法与 Ford-Fulkerson 算法不同, 它并不在整个网络中进行查找和增广, 而是对每个节点进行. 因此它不维护流的流量守恒性质, 我们定义这个不维护流量守恒性质的流为<strong>预流(preflow)</strong>, 是一个<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>V</mi><mi>&#x000D7;</mi><mi>V</mi><mo>&#x02192;</mo><mi>R</mi></mrow></math>的函数<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>f</mi></mrow></math>. 我们定义每个点的<strong>超额流(excess flow)</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>e</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo></mrow></math>为:</p>
<p><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>e</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>V</mi><mo>&#x0002C;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo>&#x0002C;</mo><mi>V</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><msub><mo>&#x02211;</mo><mrow><mi>v</mi><mo>&#x02208;</mo><mi>V</mi></mrow></msub><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo>&#x0002C;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02212;</mo><msub><mo>&#x02211;</mo><mrow><mi>v</mi><mo>&#x02208;</mo><mi>V</mi></mrow></msub><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo></mrow></math></p>
<p>但我们依然维护以下的弱化版流量守恒性质, 对于点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi><mo>&#x02208;</mo><mi>V</mi><mo>&#x02212;</mo><mo stretchy="false">&#x0007B;</mo><mi>s</mi><mo stretchy="false">&#x0007D;</mo></mrow></math>有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>e</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02265;</mo><mn>0</mn></mrow></math>.</p>
<p>若对于节点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi><mo>&#x02208;</mo><mi>V</mi><mo>&#x02212;</mo><mo stretchy="false">&#x0007B;</mo><mi>s</mi><mo>&#x0002C;</mo><mi>t</mi><mo stretchy="false">&#x0007D;</mo></mrow></math>有<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>e</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003E;</mo><mn>0</mn></mrow></math>, 则称节点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math><strong>溢出(overflowing)</strong>.</p>
<h4>1.3.1 基本思路</h4>
<p>我们为网络<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>G</mi><mo>&#x0003D;</mo><mo stretchy="false">&#x00028;</mo><mi>V</mi><mo>&#x0002C;</mo><mi>E</mi><mo stretchy="false">&#x00029;</mo></mrow></math>的每个点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>赋予一个<strong>高度函数</strong><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mi>:</mi><mi>V</mi><mo>&#x02192;</mo><mi>N</mi></mrow></math>, 固定<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>s</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mo stretchy="false">&#x0007C;</mo><mi>V</mi><mo stretchy="false">&#x0007C;</mo></mrow></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>t</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003D;</mo><mn>0</mn></mrow></math>. 且对于<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x02200;</mo><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02208;</mo><msub><mi>E</mi><mi>f</mi></msub></mrow></math>, 我们可以维护<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo><mo>&#x02264;</mo><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><mn>1</mn></mrow></math>.</p>
<h4>引理 2.3</h4>
<blockquote>
<p>根据定义我们可以直接得到: 对于点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mo>&#x02208;</mo><mi>V</mi></mrow></math>, 若<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>u</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0003E;</mo><mi>h</mi><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002B;</mo><mn>1</mn></mrow></math>, 则<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>&#x027E8;</mi><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mi>&#x027E9;</mi><mo>&#x02209;</mo><msub><mi>E</mi><mi>f</mi></msub></mrow></math>. </p>
</blockquote>
<p>对于每个节点, 我们把它的超额流向比它高度低的节点进行<strong>推送操作(push)</strong>.</p>
<p>如果节点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi></mrow></math>溢出且已完成推送, 我们需要改变其高度以继续推送, 这就是<strong>重贴标签操作(relabel)</strong>.</p>
<h4>1.3.2 推送操作</h4>
<p>根据引理1, 对于点<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>u</mi><mo>&#x0002C;</mo><mi>v</mi><mo>&#x02208;</mo><mi>V</mi></mrow></math>, 若<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002A;</mo><mi>待</mi><mi>补</mi><mi>充</mi><mo>&#x0002A;</mo><mi>#</mi><mi>#</mi><mn>2</mn><mo>&#x0002E;</mo><mi>最</mi><mi>小</mi><mi>割</mi><mi>问</mi><mi>题</mi><mi>由</mi><mi>于</mi><mi>最</mi><mi>大</mi><mi>流</mi><mi>算</mi><mi>法</mi><mi>本</mi><mi>身</mi><mi>的</mi><mi>应</mi><mi>用</mi><mi>较</mi><mi>少</mi><mo>&#x0002C;</mo><mi>所</mi><mi>以</mi><mi>基</mi><mi>本</mi><mi>只</mi><mi>有</mi><mi>模</mi><mi>板</mi><mi>题</mi><mo>&#x0002E;</mo><mi>但</mi><mi>是</mi><mi>根</mi><mi>据</mi><mi>定</mi><mi>理</mi><mn>1.6</mn><mo stretchy="false">&#x00028;</mo><mi>最</mi><mi>大</mi><mi>流</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>定</mi><mi>理</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002C;</mo><mi>求</mi><mi>解</mi><mi>最</mi><mi>大</mi><mi>流</mi><mi>时</mi><mi>可</mi><mi>以</mi><mi>同</mi><mi>时</mi><mi>求</mi><mi>解</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>的</mi><mi>容</mi><mi>量</mi><mo>&#x0002C;</mo><mi>所</mi><mi>以</mi><mi>有</mi><mi>更</mi><mi>多</mi><mi>的</mi><mi>应</mi><mi>用</mi><mo>&#x0002E;</mo><mi>最</mi><mi>小</mi><mi>割</mi><mi>问</mi><mi>题</mi><mi>的</mi><mi>主</mi><mi>要</mi><mi>应</mi><mi>用</mi><mi>是</mi><mi>二</mi><mi>分</mi><mi>图</mi><mi>最</mi><mi>大</mi><mi>匹</mi><mi>配</mi><mi>和</mi><mi>最</mi><mi>大</mi><mi>权</mi><mi>闭</mi><mi>合</mi><mi>图</mi><mo>&#x0002C;</mo><mi>分</mi><mi>别</mi><mi>会</mi><mi>在</mi><mn>0005</mn><mi>篇</mi><mi>和</mi><mn>0010</mn><mi>篇</mi><mi>中</mi><mi>讲</mi><mi>解</mi><mo>&#x0002E;</mo><mi>这</mi><mi>里</mi><mi>讲</mi><mi>解</mi><mi>用</mi><mi>网</mi><mi>络</mi><mi>流</mi><mi>求</mi><mi>解</mi><mi>规</mi><mi>划</mi><mi>问</mi><mi>题</mi><mi>的</mi><mi>基</mi><mi>本</mi><mi>范</mi><mi>式</mi><mi>和</mi><mi>两</mi><mi>个</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>的</mi><mi>技</mi><mi>巧</mi><mo>&#x0002E;</mo><mi>#</mi><mi>#</mi><mi>#</mi><mn>2.1</mn><mi>网</mi><mi>络</mi><mi>流</mi><mi>求</mi><mi>解</mi><mi>规</mi><mi>划</mi><mi>问</mi><mi>题</mi><mi>网</mi><mi>络</mi><mi>流</mi><mi>的</mi><mi>应</mi><mi>用</mi><mi>很</mi><mi>多</mi><mo>&#x0002C;</mo><mi>但</mi><mi>其</mi><mi>根</mi><mi>本</mi><mi>都</mi><mi>是</mi><mi>通</mi><mi>过</mi><mi>将</mi><mi>规</mi><mi>划</mi><mi>问</mi><mi>题</mi><mi>构</mi><mi>建</mi><mi>为</mi><mi>网</mi><mi>络</mi><mo>&#x0002C;</mo><mi>再</mi><mi>利</mi><mi>用</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>求</mi><mi>解</mi><mo>&#x0002E;</mo><mi>下</mi><mi>面</mi><mi>引</mi><mi>入</mi><mi>经</mi><mi>典</mi><mi>的</mi><mo>&#x0002A;</mo><mo>&#x0002A;</mo><mi>二</mi><mi>者</mi><mi>选</mi><mi>其</mi><mi>一</mi><mo>&#x0002A;</mo><mo>&#x0002A;</mo><mi>最</mi><mi>小</mi><mi>割</mi><mi>题</mi><mi>目</mi><mo>&#x0002C;</mo><mi>让</mi><mi>读</mi><mi>者</mi><mi>对</mi><mi>利</mi><mi>用</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>求</mi><mi>解</mi><mi>规</mi><mi>划</mi><mi>问</mi><mi>题</mi><mi>有</mi><mi>一</mi><mi>个</mi><mi>初</mi><mi>步</mi><mi>的</mi><mi>了</mi><mi>解</mi><mo>&#x0002E;</mo><mi>#</mi><mi>#</mi><mi>#</mi><mi>#</mi><mn>2.1</mn><mi>.1</mi><mi>问</mi><mi>题</mi><mi>模</mi><mi>型</mi><mi>我</mi><mi>们</mi><mi>有</mi></mrow></math> n <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>个</mi><mi>物</mi><mi>品</mi><mi>和</mi><mi>两</mi><mi>个</mi><mi>集</mi><mi>合</mi></mrow></math> A,B<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002C;</mo><mi>如</mi><mi>果</mi><mi>一</mi><mi>个</mi><mi>物</mi><mi>品</mi><mi>没</mi><mi>有</mi><mi>放</mi><mi>入</mi></mrow></math> A <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>集</mi><mi>合</mi><mi>会</mi><mi>花</mi><mi>费</mi></mrow></math> a_i<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002C;</mo><mi>没</mi><mi>有</mi><mi>放</mi><mi>入</mi></mrow></math> B <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>集</mi><mi>合</mi><mi>会</mi><mi>花</mi><mi>费</mi></mrow></math> b_i<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002E;</mo><mi>还</mi><mi>有</mi><mi>若</mi><mi>干</mi><mi>个</mi><mi>形</mi><mi>如</mi></mrow></math> u_i,v_i,w_i <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>限</mi><mi>制</mi><mi>条</mi><mi>件</mi><mo>&#x0002C;</mo><mi>表</mi><mi>示</mi><mi>如</mi><mi>果</mi></mrow></math> u_i <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>和</mi></mrow></math> v_i <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>同</mi><mi>时</mi><mi>不</mi><mi>在</mi><mi>一</mi><mi>个</mi><mi>集</mi><mi>合</mi><mi>会</mi><mi>花</mi><mi>费</mi></mrow></math> w_i<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002E;</mo><mi>每</mi><mi>个</mi><mi>物</mi><mi>品</mi><mi>必</mi><mi>须</mi><mi>且</mi><mi>只</mi><mi>能</mi><mi>属</mi><mi>于</mi><mi>一</mi><mi>个</mi><mi>集</mi><mi>合</mi><mo>&#x0002C;</mo><mi>求</mi><mi>最</mi><mi>小</mi><mi>的</mi><mi>代</mi><mi>价</mi><mo>&#x0002E;</mo><mi>#</mi><mi>#</mi><mi>#</mi><mi>#</mi><mn>2.1</mn><mi>.2</mi><mi>求</mi><mi>解</mi><mi>思</mi><mi>路</mi><mi>我</mi><mi>们</mi><mi>对</mi><mi>于</mi><mi>每</mi><mi>个</mi><mi>集</mi><mi>合</mi><mi>设</mi><mi>置</mi><mi>超</mi><mi>级</mi><mi>源</mi><mi>点</mi></mrow></math> s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>和</mi><mi>超</mi><mi>级</mi><mi>汇</mi><mi>点</mi></mrow></math> t<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002E;</mo><mi>对</mi><mi>每</mi><mi>个</mi><mi>物</mi><mi>品</mi></mrow></math>i<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>建</mi><mi>一</mi><mi>个</mi><mi>点</mi></mrow></math>i<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002C;</mo><mi>由</mi></mrow></math> s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>向</mi></mrow></math>i<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>连</mi><mi>一</mi><mi>条</mi><mi>容</mi><mi>量</mi><mi>为</mi></mrow></math> a_i <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>的</mi><mi>边</mi><mo>&#x0002C;</mo><mi>向</mi></mrow></math> t <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>连</mi><mi>一</mi><mi>条</mi><mi>容</mi><mi>量</mi><mi>为</mi></mrow></math> b_i <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>的</mi><mi>边</mi><mo>&#x0002E;</mo><mi>对</mi><mi>于</mi><mi>限</mi><mi>制</mi><mi>条</mi><mi>件</mi></mrow></math> u_i,v_i,w_i<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002C;</mo><mi>我</mi><mi>们</mi><mi>在</mi></mrow></math> u_i,v_i <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>之</mi><mi>间</mi><mi>连</mi><mi>容</mi><mi>量</mi><mi>为</mi></mrow></math> w_i <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>的</mi><mi>双</mi><mi>向</mi><mi>边</mi><mo>&#x0002E;</mo><mi>注</mi><mi>意</mi><mi>到</mi><mi>当</mi><mi>源</mi><mi>点</mi><mi>和</mi><mi>汇</mi><mi>点</mi><mi>不</mi><mi>相</mi><mi>连</mi><mi>时</mi><mo>&#x0002C;</mo><mi>代</mi><mi>表</mi><mi>这</mi><mi>些</mi><mi>点</mi><mi>都</mi><mi>选</mi><mi>择</mi><mi>了</mi><mi>其</mi><mi>中</mi><mi>一</mi><mi>个</mi><mi>集</mi><mi>合</mi><mo>&#x0002E;</mo><mi>如</mi><mi>果</mi><mi>将</mi><mi>连</mi><mi>向</mi></mrow></math> s <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>或</mi></mrow></math> t <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>的</mi><mi>边</mi><mi>割</mi><mi>开</mi><mo>&#x0002C;</mo><mi>表</mi><mi>示</mi><mi>不</mi><mi>放</mi><mi>在</mi></mrow></math> A <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>或</mi></mrow></math> B <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>集</mi><mi>合</mi><mo>&#x0002C;</mo><mi>如</mi><mi>果</mi><mi>把</mi><mi>物</mi><mi>品</mi><mi>之</mi><mi>间</mi><mi>的</mi><mi>边</mi><mi>割</mi><mi>开</mi><mo>&#x0002C;</mo><mi>表</mi><mi>示</mi><mi>这</mi><mi>两</mi><mi>个</mi><mi>物</mi><mi>品</mi><mi>不</mi><mi>放</mi><mi>在</mi><mi>同</mi><mi>一</mi><mi>个</mi><mi>集</mi><mi>合</mi><mo>&#x0002E;</mo><mi>最</mi><mi>小</mi><mi>割</mi><mi>就</mi><mi>是</mi><mi>最</mi><mi>小</mi><mi>花</mi><mi>费</mi><mo>&#x0002E;</mo><mi>#</mi><mi>#</mi><mi>#</mi><mi>#</mi><mn>2.1</mn><mi>.3</mi><mi>求</mi><mi>解</mi><mi>技</mi><mi>巧</mi><mi>在</mi><mi>利</mi><mi>用</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>求</mi><mi>解</mi><mi>规</mi><mi>划</mi><mi>问</mi><mi>题</mi><mi>中</mi><mo>&#x0002C;</mo><mi>我</mi><mi>们</mi><mi>经</mi><mi>常</mi><mi>使</mi><mi>用</mi><mi>两</mi><mi>个</mi><mi>技</mi><mi>巧</mi><mi>如</mi><mi>下</mi><mi>:</mi><mn>1</mn><mo>&#x0002E;</mo><mo>&#x0002A;</mo><mo>&#x0002A;</mo><mi>建</mi><mi>立</mi><mi>超</mi><mi>级</mi><mi>源</mi><mi>点</mi><mi>和</mi><mi>汇</mi><mi>点</mi><mo>&#x0002A;</mo><mo>&#x0002A;</mo><mo>&#x0002C;</mo><mi>相</mi><mi>信</mi><mi>读</mi><mi>者</mi><mi>在</mi><mi>上</mi><mi>面</mi><mi>的</mi><mi>例</mi><mi>子</mi><mi>中</mi><mi>已</mi><mi>经</mi><mi>对</mi><mi>此</mi><mi>技</mi><mi>巧</mi><mi>有</mi><mi>了</mi><mi>一</mi><mi>定</mi><mi>的</mi><mi>感</mi><mi>受</mi><mo>&#x0002E;</mo><mn>2</mn><mo>&#x0002E;</mo><mo>&#x0002A;</mo><mo>&#x0002A;</mo><mi>拆</mi><mi>点</mi><mo>&#x0002A;</mo><mo>&#x0002A;</mo><mo>&#x0002C;</mo><mi>即</mi><mi>将</mi><mi>一</mi><mi>个</mi><mi>点</mi><mi>拆</mi><mi>为</mi><mi>入</mi><mi>点</mi><mi>和</mi><mi>出</mi><mi>点</mi><mo>&#x0002C;</mo><mi>将</mi><mi>原</mi><mi>来</mi><mi>的</mi><mi>点</mi><mi>的</mi><mi>入</mi><mi>边</mi><mi>连</mi><mi>向</mi><mi>入</mi><mi>点</mi><mo>&#x0002C;</mo><mi>将</mi><mi>原</mi><mi>来</mi><mi>的</mi><mi>出</mi><mi>边</mi><mi>从</mi><mi>出</mi><mi>点</mi><mi>出</mi><mi>发</mi><mo>&#x0002C;</mo><mi>再</mi><mi>由</mi><mi>入</mi><mi>点</mi><mi>向</mi><mi>出</mi><mi>点</mi><mi>连</mi><mi>一</mi><mi>条</mi><mi>容</mi><mi>量</mi><mi>为</mi></mrow></math>1<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>的</mi><mi>边</mi><mo>&#x0002C;</mo><mi>这</mi><mi>样</mi><mi>可</mi><mi>以</mi><mi>保</mi><mi>证</mi><mi>这</mi><mi>个</mi><mi>点</mi><mi>只</mi><mi>被</mi><mi>选</mi><mi>一</mi><mi>次</mi><mo stretchy="false">&#x00028;</mo><mi>这</mi><mi>样</mi><mi>可</mi><mi>能</mi><mi>不</mi><mi>是</mi><mi>很</mi><mi>好</mi><mi>理</mi><mi>解</mi><mo>&#x0002C;</mo><mi>读</mi><mi>者</mi><mi>可</mi><mi>通</mi><mi>过</mi><mi>练</mi><mi>习</mi><mi>题</mi><mi>目</mi><mn>3</mn><mi>对</mi><mi>拆</mi><mi>点</mi><mi>有</mi><mi>一</mi><mi>个</mi><mi>更</mi><mi>深</mi><mi>刻</mi><mi>的</mi><mi>了</mi><mi>解</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002E;</mo><mn>3</mn><mo>&#x0002E;</mo><mo>&#x0002A;</mo><mo>&#x0002A;</mo><mi>从</mi><mi>源</mi><mi>点</mi><mi>到</mi><mi>汇</mi><mi>点</mi><mi>建</mi><mi>立</mi><mi>一</mi><mi>条</mi><mi>链</mi><mo>&#x0002A;</mo><mo>&#x0002A;</mo><mo>&#x0002C;</mo><mi>根</mi><mi>据</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>的</mi><mi>性</mi><mi>质</mi><mo>&#x0002C;</mo><mi>这</mi><mi>条</mi><mi>链</mi><mi>上</mi><mi>必</mi><mi>然</mi><mi>有</mi><mi>一</mi><mi>条</mi><mi>边</mi><mi>在</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>内</mi><mo>&#x0002C;</mo><mi>所</mi><mi>以</mi><mi>可</mi><mi>以</mi><mi>达</mi><mi>到</mi><mi>多</mi><mi>个</mi><mi>选</mi><mi>一</mi><mi>个</mi><mi>的</mi><mi>效</mi><mi>果</mi><mo>&#x0002C;</mo><mi>如</mi><mi>上</mi><mi>面</mi><mi>的</mi><mi>问</mi><mi>题</mi><mi>模</mi><mi>型</mi><mi>就</mi><mi>是</mi><mi>通</mi><mi>过</mi><mi>一</mi><mi>条</mi></mrow></math>s\rightarrow i\rightarrow t<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>的</mi><mi>链</mi><mi>完</mi><mi>成</mi><mi>二</mi><mi>选</mi><mi>一</mi><mi>的</mi><mo>&#x0002E;</mo><mi>利</mi><mi>用</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>求</mi><mi>解</mi><mi>规</mi><mi>划</mi><mi>问</mi><mi>题</mi><mi>需</mi><mi>要</mi><mi>很</mi><mi>多</mi><mi>的</mi><mi>技</mi><mi>巧</mi><mo>&#x0002C;</mo><mi>需</mi><mi>要</mi><mi>读</mi><mi>者</mi><mi>自</mi><mi>己</mi><mi>的</mi><mi>大</mi><mi>量</mi><mi>练</mi><mi>习</mi><mo>&#x0002E;</mo><mi>#</mi><mi>#</mi><mi>#</mi><mn>2.2</mn><mi>寻</mi><mi>找</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>#</mi><mi>#</mi><mi>#</mi><mi>#</mi><mn>2.2</mn><mi>.1</mi><mi>算</mi><mi>法</mi><mi>思</mi><mi>路</mi><mi>设</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>为</mi></mrow></math>{S,T}<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002C;</mo><mi>根</mi><mi>据</mi><mi>定</mi><mi>理</mi><mn>1.6</mn><mi>证</mi><mi>明</mi><mi>中</mi></mrow></math>1.6.2\implies1.6.3<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>的</mi><mi>部</mi><mi>分</mi><mo stretchy="false">&#x00028;</mo><mi>可</mi><mi>翻</mi><mi>阅</mi><mn>0001</mn><mi>篇</mi><mo stretchy="false">&#x00029;</mo><mo>&#x0002C;</mo><mi>我</mi><mi>们</mi><mi>只</mi><mi>要</mi><mi>找</mi><mi>到</mi><mi>增</mi><mi>广</mi><mi>完</mi><mi>成</mi><mi>后</mi><mi>与</mi><mi>源</mi><mi>点</mi><mi>联</mi><mi>通</mi><mi>的</mi><mi>点</mi><mi>划</mi><mi>入</mi></mrow></math>S<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>即</mi><mi>可</mi><mo>&#x0002E;</mo><mi>#</mi><mi>#</mi><mi>#</mi><mi>#</mi><mn>2.2</mn><mi>.2</mi><mi>算</mi><mi>法</mi><mi>流</mi><mi>程</mi><mn>1</mn><mo>&#x0002E;</mo><mi>我</mi><mi>们</mi><mi>先</mi><mi>在</mi><mi>图</mi><mi>上</mi><mi>进</mi><mi>行</mi><mi>最</mi><mi>大</mi><mi>流</mi><mi>求</mi><mi>解</mi><mo>&#x0002C;</mo><mi>最</mi><mi>大</mi><mi>流</mi><mi>即</mi><mi>为</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>容</mi><mi>量</mi><mo>&#x0002E;</mo><mn>2</mn><mo>&#x0002E;</mo><mi>然</mi><mi>后</mi><mi>直</mi><mi>接</mi><mi>从</mi><mi>源</mi><mi>点</mi><mi>开</mi><mi>始</mi><mi>D</mi><mi>F</mi><mi>S</mi><mo>&#x0002C;</mo><mi>对</mi><mi>于</mi><mi>所</mi><mi>有</mi><mi>能</mi><mi>在</mi><mi>残</mi><mi>余</mi><mi>网</mi><mi>络</mi><mi>上</mi><mi>到</mi><mi>达</mi><mi>的</mi><mi>点</mi><mo>&#x0002C;</mo><mi>将</mi><mi>其</mi><mi>划</mi><mi>入</mi></mrow></math>S<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002C;</mo><mi>其</mi><mi>余</mi><mi>点</mi><mi>则</mi><mi>划</mi><mi>入</mi></mrow></math>T<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002E;</mo><mi>#</mi><mi>#</mi><mi>#</mi><mi>#</mi><mn>2.2</mn><mi>.3</mi><mi>代</mi><mi>码</mi><mi>实</mi><mi>现</mi><mi>`</mi><mi>`</mi><mi>`</mi><mi>c</mi><mi>p</mi><mi>p</mi><mi>v</mi><mi>o</mi><mi>i</mi><mi>d</mi><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy="false">&#x00028;</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi>c</mi><mi>u</mi><mi>r</mi><mo stretchy="false">&#x00029;</mo><mrow><mi>v</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>c</mi><mi>u</mi><mi>r</mi><mo stretchy="false">]</mo><mo>&#x0003D;</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>;</mi><mo>&#x0002F;</mo><mo>&#x0002F;</mo><mi>存</mi><mi>储</mi><mi>所</mi><mi>有</mi><mi>到</mi><mi>访</mi><mi>点</mi><mo>&#x0002C;</mo><mi>对</mi><mi>于</mi><mi>点</mi><mi>u</mi><mo>&#x0002C;</mo><mi>若</mi><mi>v</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>&#x0003D;</mo><mo>&#x0003D;</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>&#x0002C;</mo><mi>则</mi><mi>点</mi><mi>v</mi><mi>在</mi><mi>S</mi><mi>中</mi><mo>&#x0002E;</mo><mi>f</mi><mi>o</mi><mi>r</mi><mo stretchy="false">&#x00028;</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi>v</mi><mn>1</mn><mo>&#x0003D;</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">[</mo><mi>c</mi><mi>u</mi><mi>r</mi><mo stretchy="false">]</mo><mi>;</mi><mi>v</mi><mn>1</mn><mo>&#x00021;</mo><mo>&#x0003D;</mo><mo>&#x02212;</mo><mn>1</mn><mi>;</mi><mi>v</mi><mn>1</mn><mo>&#x0003D;</mo><mi>a</mi><mi>e</mi><mo stretchy="false">[</mo><mi>v</mi><mn>1</mn><mo stretchy="false">]</mo><mo>&#x0002E;</mo><mi>n</mi><mi>x</mi><mi>t</mi><mo stretchy="false">&#x00029;</mo><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>v</mi><mo>&#x0003D;</mo><mi>a</mi><mi>e</mi><mo stretchy="false">[</mo><mi>v</mi><mn>1</mn><mo stretchy="false">]</mo><mo>&#x0002E;</mo><mi>t</mi><mi>o</mi><mi>;</mi><mi>i</mi><mi>f</mi><mo stretchy="false">&#x00028;</mo><mi>a</mi><mi>e</mi><mo stretchy="false">[</mo><mi>v</mi><mn>1</mn><mo stretchy="false">]</mo><mo>&#x0002E;</mo><mi>c</mi><mi>f</mi><mi>&</mi><mi>&</mi><mo>&#x00021;</mo><mi>v</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">&#x00029;</mo><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy="false">&#x00028;</mo><mi>v</mi><mo stretchy="false">&#x00029;</mo><mi>;</mi><mo>&#x0002F;</mo><mo>&#x0002F;</mo><mi>a</mi><mi>e</mi><mo stretchy="false">[</mo><mi>v</mi><mn>1</mn><mo stretchy="false">]</mo><mo>&#x0002E;</mo><mi>c</mi><mi>f</mi><mi>即</mi><mi>为</mi><mi>当</mi><mi>前</mi><mi>边</mi><mi>剩</mi><mi>余</mi><mi>容</mi><mi>量</mi></mrow></mrow><mi>`</mi><mi>`</mi><mi>`</mi><mi>#</mi><mi>#</mi><mi>#</mi><mn>2.3</mn><mi>最</mi><mi>小</mi><mi>化</mi><mi>割</mi><mi>边</mi><mi>数</mi><mi>量</mi><mi>如</mi><mi>果</mi><mi>需</mi><mi>要</mi><mi>在</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>的</mi><mi>前</mi><mi>提</mi><mi>下</mi><mi>最</mi><mi>小</mi><mi>化</mi><mi>割</mi><mi>边</mi><mi>数</mi><mi>量</mi><mo>&#x0002C;</mo><mi>那</mi><mi>么</mi><mi>先</mi><mi>求</mi><mi>出</mi><mi>最</mi><mi>小</mi><mi>割</mi><mo>&#x0002C;</mo><mi>把</mi><mi>没</mi><mi>有</mi><mi>满</mi><mi>流</mi><mi>的</mi><mi>边</mi><mi>容</mi><mi>量</mi><mi>改</mi><mi>成</mi></mrow></math>\infty<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mo>&#x0002C;</mo><mi>满</mi><mi>流</mi><mi>的</mi><mi>边</mi><mi>容</mi><mi>量</mi><mi>改</mi><mi>成</mi><mn>1</mn><mo>&#x0002C;</mo><mi>重</mi><mi>新</mi><mi>跑</mi><mi>一</mi><mi>遍</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>就</mi><mi>可</mi><mi>求</mi><mi>出</mi><mi>最</mi><mi>小</mi><mi>割</mi><mi>边</mi><mi>数</mi><mi>量</mi><mo>&#x0002E;</mo><mi>这</mi><mi>是</mi><mi>因</mi><mi>为</mi><mi>要</mi><mi>保</mi><mi>证</mi><mi>非</mi><mi>满</mi><mi>流</mi><mi>边</mi><mi>依</mi><mi>然</mi><mi>不</mi><mi>满</mi><mi>流</mi><mo>&#x0002C;</mo><mi>改</mi><mi>成</mi></mrow></math>\infty</p></div>
    </body>
</html>
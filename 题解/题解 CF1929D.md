# 题解 CF1929D

题目链接：[洛谷题目链接](https://www.luogu.com.cn/problem/CF1929D)，[CF题目链接](https://codeforces.com/problemset/problem/1929/D)。

更好的阅读体验：[link](https://www.luogu.com.cn/blog/fugi-tech/solution-CF1929D)。

## 1. 题意简述

有一棵 $n$ 个节点的树（$2\le n\le 3\times10^5$），可以将某些节点设为**危险的**，问有多少种方法选择危险节点，且使得树上的任意一条简单路径包含的危险的节点个数不超过 $2$（对 $998244353$ 取模）。

## 2. 求解思路

我们发现这道题需要统计方法数，所以我们优先考虑 DP。由于直接统计不太方便，我们对其性质进行分析。

可以发现，如果任意叶子到根的路径上的危险节点个数不超过 $1$，则这种方案一定是合法的。这是因为我们可以将 $u$ 到 $v$ 的简单路径拆分为 $u-\operatorname{lca}(u,v)$ 和 $\operatorname{lca}(u,v)-v$，而这两段路径的危险节点个数均不超过 $1$，所以总危险节点个数不超过 $2$。

对于这种情况，其方案数的统计是较为简单的。我们设 $dp_u$ 表示以 $u$ 为根的子树中使得任意叶子到 $u$ 的路径上的危险节点个数不超过 $1$ 的方案数。则对于 $u$，若 $u$ 的儿子构成的集合为 $\operatorname{son}(u)$，可列状态转移方程 $dp_u=\prod_{v\in \operatorname{son}(u)}dp_v+1$。其中将 $dp_v$ 乘起来代表如果 $u$ 不危险，则儿子可以随便选。而 $1$ 代表 $u$ 危险而 $u$ 子树内其他节点均不危险的情况。特别的，对于叶子节点，其 $dp$ 值为 $2$，即选或不选。

而对于任意叶子到根的路径上的危险节点个数为 $2$ 的情况（显然不可能超过 $2$），我们设任意一条叶子到根的危险节点个数为 $2$ 的路径上较高的危险节点为 $u$。则其余的危险节点显然只能在以 $u$ 的唯一一个儿子为根的子树中选，否则可以构造一条从以 $u$ 的某个儿子为根的子树中的一个危险点到 $u$，再到另外的一个危险点的非法路径。所以点 $u$ 在这种情况下贡献的答案为 $\sum_{v\in son(u)}(dp_v-1)$，减去 $1$ 的原因是要排除以某个儿子为根的子树中一个也不选的情况。

综上，如果设根为 $1$，则最终的答案为：

 $$dp_1+\sum_{u\in V}\sum_{v\in son(u)}(dp_v-1)=\sum_{u\in V}dp_u-n+1$$

时间复杂度显然为 $O(n)$。

## 3. 代码实现

代码实现还是较为简单的，只要学过树形 DP 就可以看懂。~~不过本蒟蒻的码风可能不太正常。~~

```cpp
#include<iostream>
#include<vector>
using namespace std;
const int maxn=3e5+5,mod=998244353;
typedef long long ll;
vector<int> G[maxn];
ll dp[maxn],ans;
void dfs(int cur,int fa)
{
	dp[cur]=1;
	for(int v1=0;v1<G[cur].size();v1++)
	{
		int v=G[cur][v1];
		if(v==fa)continue;
		dfs(v,cur);
		dp[cur]=dp[cur]*dp[v]%mod;
	}
	dp[cur]++;
	ans+=dp[cur]; 
}
int main()
{
	int it;
	scanf("%d",&it);
	while(it--)
	{
		int in;
		scanf("%d",&in);
		for(int v1=1;v1<=in;v1++)G[v1].clear();
		for(int v1=1;v1<=in-1;v1++)
		{
			int ix,iy;
			scanf("%d %d",&ix,&iy);
			G[ix].push_back(iy);
			G[iy].push_back(ix);
		}
		ans=1-in;
		dfs(1,0);
		printf("%lld\n",ans%mod);
	}
	return 0;
}
```